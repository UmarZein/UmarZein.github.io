[{"content":"The idea was fully inspired by ThePrimeagen\u0026rsquo;s 2300 Devs vs 1 Dev VOD in which his twitch\u0026rsquo;s chat competed against him in a coding race wherein they had to sum an array value whilst he had to code binary search and hello world in expressjs. The twist is that chat\u0026rsquo;s messages had to be somehow combined and piped into his editor.\nWith half of his twitch chat having more than 3 seconds of video delay and a quarter with more than 5 \u0026mdash; which means they didn\u0026rsquo;t get to play \u0026mdash; it took around 8 minutes for chat to write values.reduce((x,a)=\u0026gt;x+a).\nNow, of course, chat\u0026rsquo;s speed is bound by their stupidity, but I see an opportunity for this to become a fair(er) game.\nThe Voice of the Hivemind The aggregation method used to select an action was to elect the most frequent 1-character message (or \u0026lt;backspace\u0026gt; and other special characters) in chat over a 5-second period (which we call a round). While it\u0026rsquo;s certainly intuitive and functional, we can think of a better way.\nThroughout this article, different approach will be applied to the following sample of messages to illustrate its effect.\nchatter#23: \u0026#34;const sum = arr\u0026#34; chatter#27: \u0026#34;const sum = arr.re\u0026#34; chatter#67: \u0026#34;const tot = arr.reduce\u0026#34; chatter#68: \u0026#34;const x = 0\u0026#34; chatter#69: \u0026#34;const sum = \u0026#34; chatter#61: \u0026#34;const total\u0026#34; chatter#65: \u0026#34;let sum = 0; arr.forEach(n =\u0026gt; sum += n);\u0026#34; chatter#34: \u0026#34;let tot =\u0026#34; chatter#38: \u0026#34;lol\u0026#34; chatter#31: \u0026#34;let sum = 0; for(let i = 0\u0026#34; chatter#22: \u0026#34;const sum = arr.reduce((n, {Amount})\u0026#34; chatter#98: \u0026#34;lol\u0026#34; chatter#21: \u0026#34;const x = arr.reduce\u0026#34; chatter#33: \u0026#34;arr arr arr arr arr\u0026#34; It will also be tested against a bigger dataset accross a spectrum of entropy, on the low end of which would be a dataset with low number of unique messages w.r.t. the number of messages and the opposite on the other end\nBeyond one character Looking at the example above, it\u0026rsquo;s reasonable to say that a few of the possible aggregation results would be const sum = or let sum = 0 or just const. But it\u0026rsquo;s not as simple as \u0026ldquo;the most common x\u0026rdquo; since it shouldn\u0026rsquo;t be lol, even though it\u0026rsquo;s the most common whole message, and it definitely shouldn\u0026rsquo;t be (space), the most common substring. The most common word? That would be arr. There\u0026rsquo;s more factor in the game\nAs guidelines, the aggregated message should:\nbe commonly found in the beginnings of messages\nnot lean towards very short messages\nThe Proportional Falloff Algorithm TODO this is not exactly how it works: it needs to be reworded\nThis algorithm needs two real-number parameters $T_a,T_b \\in [0,1]$. It starts off by identifying the most common first letter (in our case, c) and appending it into the result buffer. Then, it goes into a loop:\nFilter only messages that start with the result buffer (in our first iteration, that would be 8 messages coming from chatter # 23, 27, 67, etc.)\nFind the most common next letter (in our first iteration, the o in const among those 8 messages)\nCalculate the proportion $P_a$ of the number of messages that continue with the next letter w.r.t. the number of messages that start with the result buffer (100% in our first iteration since all of the messages that start with c also starts with co)\nCalculate the proportion $P_b$ of the number of messages that start with only the result buffer w.r.t. the number of total messages (57% in our case)\nIf the proportion $P_a$ is less than or equal to a threshold $T_a$ which we decide, return the result buffer\nIf the proportion $P_b$ is less than or equal to a threshold $T_b$ which we decide, return the result buffer\nAppend the next letter to the result buffer\nRepeat the cycle\nThe lower $T_a$, the more permissive the algorithm will be in accepting longer and biased messages. $T_b$ is used to mitigate an issue where the algorithm slides into a hyper-specific result when all the falloffs are smooth\nApplying the algorithm with our example, here some results:\nHaving $T_a \\gt 0.5$ results in const , unless $T_b \\gt 0.5$ in which case it will only output c\nWhen $T_a \\le 0.5$, $T_b=0$ yields the entirity of chatter#22\u0026rsquo;s message, const sum = arr.reduce((n, {Amount}). $T_b=0.1$ yields const sum = arr.re. $T_b=0.2$ yields const sum = arr. $T_b \\in\\{0.3, 0.4, 0.5\\}$ yields const Even though it depends in one\u0026rsquo;s case, I recommend $0.3 \\lt T_a \\le 0.5$ and $0.1 \\le T_b \\le 0.5$\nSince we have only introduced 1 algorithm, it is not yet appropriate to benchmark it. Instead, we will compare it with other algorithms later on\nFormula based approach Since the aim is to capture subprefixes which are as long and common as possible, we can remodel this as a mathematical optimization problem. If $P$ is the subprefix, $L$ is the subprefix length, and $N$ is the subprefix frequency, this problem then becomes\n$$ \\mathrm{max}_P [LN] $$\nbasically, this is saying, we are to change $P$ such that $LN$ is maximized\nHere is an example score function, $LN$, which we will try to maximize w.r.t. $P$, the subprefix. With this formula, if the prefix length$L$ doubles, so does the score. However, that will usually reduce its occurrence/frequency $N$ and thus also affecting the score. Moreover, this function is naive and might contain subtle pitfalls such as equally honoring $L$ and $N$. We will try different variations such as $L(N-1), LN^2, LN(N-1), \\dots$\nUnfortunately, with the example, not a lot can be said about their differences because they all returned const except when $L$ has a higher power than $N$ like in $L^2N$ or $L^3N^2$ which will return chatter#22\u0026rsquo;s full message\nTrie Optimization Since we are searching for prefixes, the trie data structure may prove to be effecient in some cases. The trie that can be implemented in this case is visualized as follows:\nTODO Continue this\nTODO Tf-Idf but opposite? Df-Itf?\n","permalink":"http://localhost:1313/fun/audience_programming/","summary":"The idea was fully inspired by ThePrimeagen\u0026rsquo;s 2300 Devs vs 1 Dev VOD in which his twitch\u0026rsquo;s chat competed against him in a coding race wherein they had to sum an array value whilst he had to code binary search and hello world in expressjs. The twist is that chat\u0026rsquo;s messages had to be somehow combined and piped into his editor.\nWith half of his twitch chat having more than 3 seconds of video delay and a quarter with more than 5 \u0026mdash; which means they didn\u0026rsquo;t get to play \u0026mdash; it took around 8 minutes for chat to write values.","title":"Audience Programming"}]